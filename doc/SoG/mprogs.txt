#
# $Id: mprogs.txt,v 1.24 2004-02-12 20:17:23 sg Exp $
#

MPC code style
--------------

man 9 style with replacing '\t' (tab) with 8 (eight) spaces.

MPC comments
------------
Both C and C++ style comments are accepted.

Examples:

// C++ style comment
/* C style comment */

MPC types and classes
---------------------

int	-- integer
string	-- a string
Char	-- character or mobile (CHAR_DATA)
Obj	-- object (OBJ_DATA)
Room	-- Room (ROOM_INDEX_DATA)

'int' and 'string' are basic types and do not have properties
'Char', 'Obj' and 'Room' properties are listed below:

class Char {
	mutable int gold;	// количество золотых монет
	mutable int silver;	// количество серебряных монет

	int stat_str;		// сила
	int stat_int;		// интеллект
	int stat_wis;		// мудрость
	int stat_dex;		// ловкость
	int stat_con;		// телосложение
	int stat_cha;		// charisma

	mutable int hit;	// текущее количество hp
	int max_hit;		// максимальное количество hp
	mutable int mana;	// текущее количество mana
	int max_mana;		// максимальное количество mana
	mutable int move;	// текущее количество moves
	int max_move;		// максимальное количество moves

	int level;		// уровень (с +lev)
	int real_level;		// уровень (без +lev)

	string clan;		// клан, или NULL
	int ethos;		// ethos (ETHOS_LAWFUL, ETHOS_CHAOTIC, etc.)
	Char fighting;		// чар, с которым дерется ch (или NULL)
	string hometown;	// 'hometown' для !npc,
				// для npc зона в которой он
				// заресечен, или (если родился не через reset)
				// зона в которой находится в настоящий момент
	Room in_room;		// комната, в которой находится чар
	int luck;		// удача
	Char pet;		// pet чара, или NULL
	int position;		// позиция (POS_RESTING, POS_FIGHTING etc.)
	int quest_time;		// quest time (-1 если нет квеста или npc)
	string race;		// раса
	int sex;		// пол (SEX_MALE, SEX_FEMALE etc.)
	int size;		// размер (SIZE_LARGE, SIZE_MEDIUM etc.)
	int vnum;		// vnum (0 для !npc)
};

class Obj {
	Char carried_by;	// чар, у которого находится объект,
				// или NULL
	Obj in_obj;		// объект, в котором находится
				// этот объект, или NULL
	Room in_room;		// комната, в которой находится
				// объект, или NULL

	int cost;		// стоимость
	int item_type;		// тип объекта (ITEM_STAFF, ITEM_WEAPON etc.)
	mutable int level;	// уровень
	int vnum;		// vnum
	mutable int timer;	// таймер на этом объекте
	mutable int v_dice_type;// dice type (v2) для ITEM_WEAPON,
				// 0 для остальных
	int wear_loc;		// слот, где одет объект (WEAR_XXX),
				// или WEAR_NONE
};

class Room {
	int sector_type;	// тип сектора (SECTOR_XXX)
	int vnum;		// vnum
};

Properties are read-only by default. 'mutable' properties can be changed.
Properties are accessed using '->' operator:

Char owner;
owner->hit = umin(owner->hit + bonus, owner->max_hit);

MPC statements
--------------

Valid statements are:

1) 'if' operator

if (expr)
	stmt;
[else
	stmt;]

2) 'switch' operator

swtich (expr) {
case const:
	stmt;
	....
[default:
	stmt;
	...]
}

3) 'foreach' operator (see MPC Iterators)

foreach (var, iter([iter args...]))
	stmt;

4) 'return' operator

return expr;

5) expression

expr;

6) compound statement

{
	stmt;
	...
}

7) declaration

7.1) type var [= expr];
	Объявление переменной типа type с именем var (с инициализатором).

Примеры:

int i = 0;	// объявление переменной i типа int и инциализация ее нулем
string s;	// объявление переменной s типа string

7.2) {persistent | static} type var[ident];

	Объявление статической переменной типа type с именем ident,
связанной с (хранящейся в) переменной var.

Тип type может быть одним из:
	- int
	- string

Переменная var может быть следущих типов:
	- Char
	- Obj
	- Room

Указание одного из модификаторов static или persistent обязательно.
Модификатор static используется для объявления обычной статической
переменной. Модификатор persistent используется для объявления
статической переменной, которая сохраняется в pfile'е игрока, если
объект типа var сохраняется в pfile'е.

Таким образом, обычные статические переменные имеют время жизни
"до ближайшей перезагрузки", а статические переменные, объявленные с
модификатором persistent имеют неограниченное время жизни (до уничтожения
объекта var), если объект типа var это
- игрок (!is_npc)
- pet игрока
- объект, находящийся в inventory или одетый на игрока или pet'а
В остальных случаях время жизни persistent переменной совпадает со
временем жизни обычной статической переменной.

Использование статических переменных позволяет передавать информацию
из одной программы в другую (и из программы в саму себя).

Примеры:
int mob[num];	// объявление переменной num, хранящейся в переменной mob 
string actor[foobar_quest_status];
		// объявление строковой переменной foobar_quest_status,
		// хранящейся в переменной actor 

MPC expressions
---------------

All C expressions are valid in MPC:
- all arithmetic operators (+, -, /, %, *),
- all logical operators (&&, ||) with incomplete operands calculation,
- all assignment operators (=, +=, -=, /=, %=, *=, <<=, >>=)
- pre/post increment/decrement operators (pre and post ++, --)
- tertiary operator ?:
- function calls

MPC iterators
-------------

int range(int from, int to)
	all integers in range [from..to]

Char char_in_room(Room r)
	all characters in Room r

Char char_in_world()
	all characters in world

Char npc_in_world()
	all npc (mobiles) in world

Obj obj_in_obj(Obj o)
	all objects in object o (without recursion)

Obj obj_of_char(Char ch)
	all objects that are carried by ch (without recursion)

Obj obj_in_room(Room r)
	all objects in Room r

Obj obj_in_world()
	all objects in world

Examples:

int i;
foreach (i, range(0, 10)) {
	/* do something */
}

Char vch;
foreach (vch, char_in_room(ch->in_room)) {
	/* do something */
}

MPC triggers
------------

MPC программы исполняются при срабатывании триггеров.
Триггер может быть привязан к
- мобу
- объекту
- комнате
Существует также специальный тип триггера, используемый в skill spec'ах.

Подробное описание типов триггеров см. в файле triggers.txt.

Существуют два типа триггеров
- обычные
- inline

Если при создании триггера указывается название MPC
программы, которая будет исполняться при срабатывании триггера,
то создается обычный триггер.
Если при создании триггера название MPC программы не указывается,
то создается inline-триггер, который содержит код (текст) исполняемой
программы в себе (inline).

Обычные триггеры применяются в случаях, когда требуется
вызывать одну и ту же программу для большого количества разных
игровых объектов, например, в SoG 2 они использутся для реализации
механизма ROM 2.4 specials.

Inline-триггер удобно применять для использования программ, которые
специфичны для объекта, на который ставится создаваемый триггер.
Кроме того, создание и редактирование MPC программ, которые привязываются
к триггеру обычного типа, требует более высокого уровня OLC-привилегий,
тогда как для создания и редактирования MPC-кода inline-триггера
дополнительных OLC-привилегий не требуется. Еще одним преимуществом
использования inline-триггеров является компактность ареи (MPC программы
inline-триггеров сохраняются в том же .are файле, что и объекты, на
которые ставятся триггеры). Кроме этого, при использовании inline-триггеров
уменьшается количество OLC-команд, которые нужно исполнить для того, чтобы
отредактировать или откомпилировать MPC-программу, привязанную к триггеру.

MPC functions:
--------------

act(string msg, Char ch, any arg1, any arg2, int act_flags)
  выводит сообщение msg
  act_flags: TO_CHAR    -- чару ch
             TO_ROOM    -- всем в комнате кроме чара ch
	     TO_ALL     -- всем в комнате
	     TO_VICT    -- жертве (arg2)
	     TO_NOTVICT -- всем к комнате кроме чара ch и жертвы (arg2)

act_around(Room r, string text, any arg)
  text выводится в соседние с r комнаты, arg может использоваться как параметр
  в text

act_char(string msg, Char ch)
  выводит сообщение msg чару ch

act_clan(Char ch, string text, any arg)
  сообщение text выводится по клановому каналу чара ch, arg может использоваться
  как параметр в text

act_say(Char ch, string msg, any arg)
  чаром ch говорится ("say") сообщение msg, в которое подставляется
  arg как параметр ($N, $P, $T, $K etc)

act_yell(Char ch, string msg, any arg, string format)
  чаром ch выкрикивается сообщение msg, в котором могут быть использованы
  различные параметры ($N, $T etc)

affect_char(Char ch, int where, string sn, int level, int duration,
            int loc, int mod, int bits)
  вешается на чара ch указанный аффект sn с задаваемыми характеристиками
  (уровень level, длительность duration, ...)

affect_strip(Char ch, string aff)
  снимается аффект aff с чара ch

int calc_spell_damage(Char ch, int level, string sn);
  считается дамадж, который должен нанестись умением sn ("acid blast")
  уровня level чаром ch

bool can_backstab(Char ch)
  может ли чар делать backstab

backstab_char(Char ch, Char victim)
  делается backstab чаром ch чару victim

bool can_loot(Char ch, Obj p)
  может ли чар полутить (loot) объект p

bool can_see(Char ch, Char victim)
  проверяется видит ли чар ch чара victim

bool can_wear(Obj p, int wear)
  может ли объект одеться в слот wear

cast(string sn, Char ch, string arg)
  чаром ch кастится заклинание/молитва sn с аргументом arg

cast_char(string sn, Char ch, Char victim)
  чаром ch на чар victim кастится заклинание/молитва sn

cast_obj(string sn, Char ch, Obj p)
  чаром ch на объект p накладывается заклинание/молитва sn

bool char_form_is(Char ch, int form)
  есть ли у чара данная форма (FORM_UNDEAD, etc)

bool char_name_is(Char ch, string name);
  является ли name именем для чара ch

bool close_door(Char ch, string door)
  чар ch закрывает (пытается) дверь

bool close_obj(Char ch, Obj p)
  чар ch выполняет операцию закрытия объекта p

Char create_mob(int vnum, int flags)
  создает моба по его внуму

Obj create_obj(int vnum, int flags)
  создает объект по его внуму

bool damage(Char ch, Char victim, int dam, string dt, int dam_flags)
  чаром ch наносится чару victim урон в размере dam. Урон типа sn.
  ("touch", etc)

int dice(int num, int size)
  бросает num раз кубик с числом граней size

dofun(string name, Char ch, string arg)
  чар ch выполняет do-функцию 'name'

drop_obj(Char ch, Obj p)
  чаром ch бросается объект p

extract_obj(Obj p, int flags)
  уничтожает объект p

Char get_char_area(Char ch, string arg)
  чаром ch в арии, где он находится, ищется чар с именем arg
  (arg может быть vnum'ом)

Char get_char_here(Char ch, string arg)
  чаром ch в комнате, где он находится, ищется чар с именем arg
  (arg может быть vnum'ом)

Char get_char_room(Char ch, Room r, string arg)
  чаром ch в комнате r ищется чар с именем arg
  (arg может быть vnum'ом)

Char get_char_world(Char ch, string arg)
  чаром ch в мире ищется чар с именем arg (arg может быть vnum'ом)

Obj get_eq_char(Char ch, int iWear)
  возвращается объект, одетый у чара ch в слоте iWear

bool get_obj(Char ch, Obj p, Obj container, string msg_others)
  чаром ch берется объект p из container или с пола (если container == NULL)
  msg_others -- сообщение, пишущееся тем, кто стоит в той же комнате, где
  происходит действие (может быть NULL)

Obj get_obj_carry(Char ch, Char victim, string arg)
  чаром ch смотрится у чара victim, есть ли у последнего объект c 
  именем arg, arg может быть vnum'ом

Obj get_obj_here(Char ch, string arg)
  чаром ch смотрится есть ли в комнате, где находится чар ch, объект
  с именем arg (ищется на полу и у чара ch), arg может быть vnum'ом

Obj get_obj_obj(Char ch, Obj p, string arg)
  чаром ch смотрится есть ли в объекте p объект с именем arg, arg может
  быть vnum'ом

Obj get_obj_room(Char ch, Room r, string arg)
  чаром ch смотрится есть ли в комнате r объект c именем arg
  (ищется на полу), arg может быть vnum'ом

Obj get_obj_wear(Char ch, Char victim, string arg)
  чаром ch смотрится, одет ли на чаре victim объект с именем arg,
  arg может быть vnum'ом

Obj get_obj_world(Char ch, string arg)
  чаром ch ищется в мире объект с именем arg, arg может быть vnum'ом

get_pulse(

Char get_random_fighting(Char ch)
  возвращает случайного чара в одной комнате с ch, который сражается
  с ch или который сражается с чаром, который сидит верхом на ch

Room get_room_index(int vnum)
  возвращает комнату по ее внуму (NULL, если комнаты с таким внумом нет)

int get_skill(Char ch, string skill_name)
  возвращает процент знания чаром данного умения, если оно у чара есть,
  и 0 в противном случае 

bool give_obj(Char ch, Char victim, Obj p)
  чаром ch чару victim дается объект p (пытается)

handle_death(Char ch, Char victim)
  зовется функция handle_death чару ch для умершего чара victim

bool has_detect(Char ch, int f)
  есть ли у чара детект f
f может быть: ID_INVIS, ID_HIDDEN, ID_FADE, ID_IMP_INVIS, ID_BLEND,
ID_CAMOUFLAGE, ID_INFRARED, ID_UNDEAD, ID_LIFE, ID_EVIL, ID_MAGIC, ID_CHARM,
ID_TRUESEEN, ID_GOOD, ID_TREEFORM, ID_ALL_INVIS

bool has_invis(Char ch, int f)
  есть ли на чаре невидимость f (значения см в has_detect)

int has_sp(Char ch, string spn, string spn_add, string spn_rm)

inflict_effect(string effect, Char ch, int num, int dam)
  вешает (пытается повесить) на чара ch эффект effect
  уровня num, наносится урон dam

  Возможные значения effect:
  - "acid"
  - "cold"
  - "fire"
  - "poison"
  - "sand"
  - "scream"
  - "shock"

bool is_act(Char ch, int act_flags)
  стоит ли у чара ch ACT act_flags

bool is_affected(Char ch, int aff)
  наложен ли на чара ch аффект aff (e.g AFF_POISON)

bool is_awake(ch)
  char_position(ch) > POS_SLEEPING

bool is_evil(Char ch)
  имеет ли чар ch align evil

bool is_ghost(Char ch)
  является ли чар ch привидением

bool is_good(Char ch)
  имеет ли чар ch align good

bool is_immortal(Char ch)
  является ли чар ch immortal'ом

bool is_mount(Char ch, Char mob)
  служит ли mob верховым животным для чара ch

bool is_neutral(Char ch)
  имеет ли чар ch align neutral

bool is_npc(Char ch)
  является ли чар ch мобом (npc)

bool is_owner(Char ch, Obj p)
  является ли чар ch owner'ом объекта p

bool is_owner_name(Obj p, string name)
  принадлежит ли объект p чару с именем name

bool is_pumped(Char ch)
  есть ли у чара ch адреналин в крови

bool is_safe(Char ch, Char victim)

bool is_safe_nomessage(Char ch, Char victim)

bool is_same_group(Char first, Char second)
  принадлежит ли чар second группе чара first

bool is_sn_affected(Char ch, string sn)
  наложен ли на чара аффект sn (e.g. "berserk")

bool is_wanted(Char ch)
  является лм чар ch WANTED

Char load_mob(Char ch, int vnum)
  создается моб с номером vnum и ставится в комнату, где находится ch

Obj load_obj(Char ch, int vnum)
  создается объект с номером vnum и дается чару ch

bool lock_door(Char ch, string door)
  замыкается (пытается) дверь чаром ch 

bool lock_obj(Char ch, Obj p)
  замыкается (пытается) объект p чаром ch

look_char(Char ch, Char victim)
  чар ch смотрит на чара victim (делает "look")

mob_interpret(Char ch, string arg)
  чаром ch выполняется команда arg (без параметров)

multi_hit(Char ch, Char victim, string dt)
  зовется функция multi_hit (один battle round) для чара ch по жертве,
  чару victim)

int number_bits(int width)
  возвращает случайное число в диапазоне от 0 до 2^width (включительно)

int number_percent()
  возвращает случайное число от 1 до 100 (процент)

int number_range(int from, int to)
  возвращает случайное число в диапазоне от from до to

obj_cast_spell(string sn, int level, Char ch, any vo)

obj_to_char(Obj p, Char ch)
  объет p дается чару ch

obj_to_obj(Obj p, Obj obj_to)
  объект p кладется в объект obj_to

obj_to_room(Obj p, Room r)
  объект p помещается в комнату r

one_hit(Char ch, Char victim, string dt, bool secondary)
  наносится один удар чаром ch по чару victim

bool open_door(Char ch, string door)
  чар ch открывает (пытается) дверь door 

bool open_obj(Char ch, Obj p)
  открывает (пытается открыть) объект p, открывает объект чар ch

int real_char_level(Char ch)
  возвращает реальный (без +lev) уровень чара ch

bool room_is(Room r, int flags)
  есть ли у комнаты соответствующий флажок (ROOM_NOMAGIC, ROOM_LAW, etc)

say_spell(Char ch, string sn)
  произносится заклинание sn (или возносится молитва)

bool saves_spell(int ch_level, Char victim, int dam_type)
  проверяются saves в выбранному dam_type (DAM_ACID, DAM_ENERGY, etc)

set_obj_owner(Obj p, Char ch)
  owner'ом объекта p делается чар ch

social_char(string name, Char ch, Char victim)
  делается social name (e.g "smile") чаром ch чару victim

spclass_count(Char ch, string spn, string spn_add, string spn_rm)

spellfun(string fn, string sn, int level, Char ch, any vo)
  зовется спеллфункция fn уровня level на аргумент vo (Char/Obj)
  для чара ch, sn в подавляющем большинстве случаев NULL

tell_char(Char ch, Char victim, string msg)
  msg передается от чара ch чару victim посредством tell'а

int time_hour(Char ch)
  текущий час (по времени мира)

bool transfer_char(Char ch, Room r)
  переносится чар ch в комнату r

bool transfer_group(Char ch, Room r)
  переносится группа чара ch в комнату r

int umax(int i1, int i2)
  максимальное из чисел i1, i2

int umin(int i1, int i2)
  минимальное из чисел i1, i2

bool unlock_door(Char ch, door)
  размыкает (пытается) дверь, действие производит чар ch

bool unlock_obj(Char ch, Obj p)
  размыкает (пытается) объект p, действие производит чар ch

wait_state(Char ch, int dur)
  чару ch делается задержка длительностью dur

bool weapon_is(Obj p, int wclass)
  является ли p оружием класса wclass (WEAPON_SWORD, WEAPON_DAGGER etc.)

Porting ROM 2.4 mob progs:
--------------------------

isvisible проверки излишни, потому что в SoG 2 триггера
срабатывают только тогда, когда mob видит игрока

echoat $N
	act("...", mob, NULL, actor, TO_VICT);

echoaround $N
	act("...", mob, NULL, actor, TO_NOTVICT);	

oload 2345
	load_obj(mob, 2345)

purge $p
	extract_obj(obj, 0);

slay $N
	raw_kill(mob, actor);

ROM 2.4 specials:
-----------------

ROM 2.4 (and Anatolia) specials are implemented as fight or random mprogs.

When loading ROM 2.4 areas #SPECIALS section data is automatically converted
to mprog triggers for corresponding mobiles using the following table
(trig arg is set to "100"):

ROM 2.4 spec		| SoG mprogs
------------------------+---------------------------
spec_assassinater	| mob_random_assassinater
spec_breath_any		| mob_fight_breath_any
spec_breath_acid	| mob_fight_breath_acid
spec_breath_fire	| mob_fight_breath_fire
spec_breath_frost	| mob_fight_breath_frost
spec_breath_gas		| mob_fight_breath_gas
spec_breath_lightning	| mob_fight_breath_lightning
spec_captain		| mob_random_captain
			| mob_fight_cast_cleric
spec_cast_adept		| mob_random_cast_adept
spec_cast_beholder	| mob_fight_cast_beholder
spec_cast_clan		| mob_random_cast_clan
spec_cast_cleric	| mob_fight_cast_cleric
spec_cast_judge		| mob_fight_cast_judge
spec_cast_mage		| mob_fight_cast_mage
spec_cast_seneschal	| mob_fight_cast_seneschal
spec_cast_undead	| mob_fight_cast_undead
spec_executioner	| mob_random_executioner
spec_fido		| mob_random_fido
spec_guard		| mob_random_guard
spec_headlamia		| mob_random_headlamia
spec_janitor		| mob_random_janitor
spec_mayor		| mob_random_mayor
spec_nasty		| mob_random_nasty
			| mob_fight_nasty
spec_poison		| mob_fight_poison_bite
spec_special_guard	| mob_random_executioner
spec_thief		| mob_random_thief

Tartarus spec		| SoG mprogs
------------------------------------------------------
spec_demonologist	| mob_random_demonologist
			| mob_fight_demonologist

Note that spec_captain and spec_nasty are converted to two triggers.

spec_patrolman, spec_ogre_member and spec_troll_member are not
converted because we do not have area for which they were created
(Dangerous Neighbourhood).
